<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: sort/QuickSort.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: sort/QuickSort.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import 'babel-polyfill';
/* eslint-disable no-param-reassign */
/**
 * @module Quick Sort
 */

const swap = (list, pos, nextPos) => {
  const temp = list[nextPos];
  list[nextPos] = list[pos];
  list[pos] = temp;
};

/* eslint-disable no-unused-vars */
/**
 * The key process in quickSort is partition(). Target of partitions is, given an array and an
 * element x of array as pivot, put x at its correct position in sorted array and put all smaller
 * elements (smaller than x) before x, and put all greater elements (greater than x) after x. All
 * this should be done in linear time.
 *
 * The logic is simple, we start from the leftmost element and keep track of index of smaller (or
 * equal to) elements as i. While traversing, if we find a smaller element, we swap current element
 * with arr[i]. Otherwise we ignore current element.
 * @function lomutoPartitioning
 * @param  {Array} list
 * @param  {Number} low
 * @param  {Number} high
 * @return {Array}
 */
const lomutoPartitioning = (list, low, high) => {
  let pos = low - 1;
  const pivot = list[high];
  for (let j = low; j &lt;= high - 1; j++) {
    // its like starting at -1 and
    // placing all elements smaller than pivot at
    // beginning of the array
    if (list[j] &lt;= pivot) {
      pos++;
      swap(list, pos, j);
    }
  }
  swap(list, pos + 1, high);
  return pos + 1;
};
/* eslint-enable no-unused-vars */

/**
 * Hoare’s Partition Scheme works by initializing two indexes that start at two ends, the two
 * indexes move toward each other until an inversion is (A smaller value on left side and greater
 * value on right side) found.
 * Hoare’s scheme is more efficient than Lomuto’s partition scheme because it does three times fewer
 * swaps on average, and it creates efficient partitions even when all values are equal.
 * @function hoarePartition
 * @param  {Array} list
 * @param  {Number} low
 * @param  {Number} high
 * @return {Array}
 */
const hoarePartition = (list, low, high) => {
  const pivot = list[high];
  let i = low;
  let j = high;
  while (true) {
    while (list[i] &lt; pivot) {
      i++;
    }
    while (list[j] > pivot) {
      j--;
    }
    if (i >= j) {
      return j;
    }
    swap(list, i, j);
  }
};

/**
 *
 * @function quickSortHelper
 * @param  {Array} list
 * @param  {Number} low
 * @param  {Number} high
 * @return {Array}     sorted array
 */
const quickSortHelper = (list, low, high) => {
  if (low &lt; high) {
    const splitPoint = hoarePartition(list, low, high);
    quickSortHelper(list, low, splitPoint - 1);
    quickSortHelper(list, splitPoint + 1, high);
  }
  return list;
};

/**
 * QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the
 * given array around the picked pivot.
 * @param {Array} list
 */
const QuickSort = list => {
  const newList = Object.assign([], list);
  return quickSortHelper(newList, 0, newList.length - 1);
};
/* eslint-enable no-param-reassign */
export default QuickSort;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-BinaryHeap.html">BinaryHeap</a></li><li><a href="module-BinarySearch.html">BinarySearch</a></li><li><a href="module-BinaryTree.html">BinaryTree</a></li><li><a href="module-BubbleSort.html">BubbleSort</a></li><li><a href="module-InsertionSort.html">InsertionSort</a></li><li><a href="module-Quick%2520Sort.html">Quick Sort</a></li><li><a href="module-SequentialSearch.html">SequentialSearch</a></li><li><a href="module-ShortBubbleSort.html">ShortBubbleSort</a></li></ul><h3>Classes</h3><ul><li><a href="module-BinaryHeap-BinaryHeap.html">BinaryHeap</a></li><li><a href="module-BinaryTree-BinaryTree.html">BinaryTree</a></li></ul><h3>Global</h3><ul><li><a href="global.html#buildParseTree">buildParseTree</a></li><li><a href="global.html#evaluateTree">evaluateTree</a></li><li><a href="global.html#inOrderTraversal">inOrderTraversal</a></li><li><a href="global.html#mirrorTree">mirrorTree</a></li><li><a href="global.html#postOrderTraversal">postOrderTraversal</a></li><li><a href="global.html#preOrderTraversal">preOrderTraversal</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Aug 02 2017 02:02:57 GMT+0530 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
